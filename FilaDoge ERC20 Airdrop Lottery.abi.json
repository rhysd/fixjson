[{"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"donation_coop_pool","type":"address"},{"internalType":"address","name":"future_event_pool","type":"address"},{"internalType":"uint256","name":"initialLotteryStartTime","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"receiver1","type":"address"},{"internalType":"address","name":"receiver2","type":"address"}],"name":"airDrop1","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"receiverList","type":"address[]"}],"name":"airDrop2","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"newLotteryStartTime","type":"uint256"}],"name":"changeLotteryStartTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"changeOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"gamblerList","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"gambler","type":"address"}],"name":"gamblerRewardReceived","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"gamblers","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"invitee","type":"address"}],"name":"hasBeenInvited","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"gambler","type":"address"}],"name":"hasGambled","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hasRewardedGamblerList","outputs":[{"components":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"internalType":"struct FilaDoge.ValuePair[]","name":"result","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hasRewardedInviteeAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hasRewardedInviteeList","outputs":[{"components":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"internalType":"struct FilaDoge.ValuePair[]","name":"result","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hasRewardedInvitees","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hasRewardedInviterAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hasRewardedInviterList","outputs":[{"components":[{"internalType":"address","name":"account","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"internalType":"struct FilaDoge.ValuePair[]","name":"result","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"hasRewardedInviters","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"inviteeList","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"invitee","type":"address"}],"name":"inviteeRewardReceived","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"inviter","type":"address"}],"name":"inviterRewardReceived","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isLotteryStarted","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"inviter","type":"address"},{"internalType":"address","name":"gambler","type":"address"}],"name":"lottery","outputs":[{"internalType":"uint256","name":"inviterReward","type":"uint256"},{"internalType":"uint256","name":"gamblerReward","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"lotteryReleasedAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lotteryStartTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"maxSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"inviter","type":"address"},{"internalType":"address","name":"invitee","type":"address"}],"name":"mint","outputs":[{"internalType":"uint256","name":"inviterReward","type":"uint256"},{"internalType":"uint256","name":"inviteeReward","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextInviteeReward","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]+                                           ~
The ampersand (&) character is not allowed. The & operator is reserved for future use; wrap an      
ampersand in double quotation marks ("&") to pass it as part of a string.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : AmpersandNotAllowed
 
PS C:\Users\ts> function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
>>                                  url, statusCode, statusMessage, upgrade,
>>                                  shouldKeepAlive) {
>>   const parser = this;
>>   const { socket } = parser;
>>
>>   if (headers === undefined) {
>>     headers = parser._headers;
>>     parser._headers = [];
>>   }
>>
>>   if (url === undefined) {
>>     url = parser._url;
>>     parser._url = '';
>>   }
>>
>>   // Parser is also used by http client
>>   const ParserIncomingMessage = (socket && socket.server &&
>>                                  soc
Oops, something went wrong.  Please report this bug with the details below.
Report on GitHub: https://github.com/lzybkr/PSReadLine/issues/new
-----------------------------------------------------------------------
Last 200 Keys:
 Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space e r r o r . b y t e L e n g t h Space - Space 1 ) ; Enter
 Space Space Space Space Space Space r e t u r n Space b u f . t o S t r i n g ( ' u t f 8 ' ) ; Enter
 Space Space Space Space } Enter
 Space Space } Enter
 Space Space r e q u i r e ( ' a s s e r t ' ) . f a i l ( ' T h i s Space s h o u l d Space n o t Space h a p p e n ' ) ; Enter
 } Enter
 Enter
 m o d u l e . e x p o r t s Space = Space { Space s e r i a l i z e E r r o r , Space d e s e r i a l i z e E r r o r Space } ; Enter


Exception:
System.ArgumentOutOfRangeException: The value must be greater than or equal to zero and less than the console's buffer size in that dimension.
Parameter name: top
Actual value was -7.
   at System.Console.SetCursorPosition(Int32 left, Int32 top)
   at Microsoft.PowerShell.PSConsoleReadLine.ReallyRender(RenderData renderData, String defaultColor)
   at Microsoft.PowerShell.PSConsoleReadLine.ForceRender()
   at Microsoft.PowerShell.PSConsoleReadLine.Insert(Char c)
   at Microsoft.PowerShell.PSConsoleReadLine.SelfInsert(Nullable`1 key, Object arg)
   at Microsoft.PowerShell.PSConsoleReadLine.ProcessOneKey(ConsoleKeyInfo key, Dictionary`2 dispatchTable, Boolean ignoreIfNoAction, Object arg)
   at Microsoft.PowerShell.PSConsoleReadLine.InputLoop()
   at Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Runspace runspace, EngineIntrinsics engineIntrinsics)
-----------------------------------------------------------------------
PS C:\Users\ts> function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
>>                                  url, statusCode, statusMessage, upgrade,
>>                                  shouldKeepAlive) {
>>   const parser = this;
>>   const { socket } = parser;
>>
>>   if (headers === undefined) {
>>     headers = parser._headers;
>>     parser._headers = [];
>>   }
>>
>>   if (url === undefined) {
>>     url = parser._url;
>>     parser._url = '';
>>   }
>>
>>   // Parser is also used by http client
>>   const ParserIncomingMessage = (socket && socket.server &&
>>                                  socket.server[kIncomingMessage]) ||
>>                                  IncomingMessage;
>>
>>   const incoming = parser.incoming = new ParserIncomingMessage(socket);
>>   incoming.httpVersionMajor = versionMajor;
>>   incoming.httpVersionMinor = versionMinor;
>>   incoming.httpVersion = `${versionMajor}.${versionMinor}`;
>>   incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
>>                                   parser.joinDuplicateHeaders;
>>   incoming.url = url;
>>   incoming.upgrade = upgrade;
>>
>>   let n = headers.length;
>>
>>   // If parser.maxHeaderPairs <= 0 assume that th
Oops, something went wrong.  Please report this bug with the details below.
Report on GitHub: https://github.com/lzybkr/PSReadLine/issues/new
-----------------------------------------------------------------------
Last 200 Keys:
 Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space e r r o r . b y t e L e n g t h Space - Space 1 ) ; Enter
 Space Space Space Space Space Space r e t u r n Space b u f . t o S t r i n g ( ' u t f 8 ' ) ; Enter
 Space Space Space Space } Enter
 Space Space } Enter
 Space Space r e q u i r e ( ' a s s e r t ' ) . f a i l ( ' T h i s Space s h o u l d Space n o t Space h a p p e n ' ) ; Enter
 } Enter
 Enter
 m o d u l e . e x p o r t s Space = Space { Space s e r i a l i z e E r r o r , Space d e s e r i a l i z e E r r o r Space } ; Enter


Exception:
System.ArgumentOutOfRangeException: The value must be greater than or equal to zero and less than the console's buffer size in that dimension.
Parameter name: top
Actual value was -21.
   at System.Console.SetCursorPosition(Int32 left, Int32 top)
   at Microsoft.PowerShell.PSConsoleReadLine.ReallyRender(RenderData renderData, String defaultColor)
   at Microsoft.PowerShell.PSConsoleReadLine.ForceRender()
   at Microsoft.PowerShell.PSConsoleReadLine.Insert(Char c)
   at Microsoft.PowerShell.PSConsoleReadLine.AcceptLineImpl(Boolean validate)
   at Microsoft.PowerShell.PSConsoleReadLine.ProcessOneKey(ConsoleKeyInfo key, Dictionary`2 dispatchTable, Boolean ignoreIfNoAction, Object arg)
   at Microsoft.PowerShell.PSConsoleReadLine.InputLoop()
   at Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Runspace runspace, EngineIntrinsics engineIntrinsics)
-----------------------------------------------------------------------
PS C:\Users\ts> function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
>>                                  url, statusCode, statusMessage, upgrade,
>>                                  shouldKeepAlive) {
>>   const parser = this;
>>   const { socket } = parser;
>>
>>   if (headers === undefined) {
>>     headers = parser._headers;
>>     parser._headers = [];
>>   }
>>
>>   if (url === undefined) {
>>     url = parser._url;
>>     parser._url = '';
>>   }
>>
>>   // Parser is also used by http client
>>   const ParserIncomingMessage = (socket && socket.server &&
>>                                  socket.server[kIncomingMessage]) ||
>>                                  IncomingMessage;
>>
>>   const incoming = parser.incoming = new ParserIncomingMessage(socket);
>>   incoming.httpVersionMajor = versionMajor;
>>   incoming.httpVersionMinor = versionMinor;
>>   incoming.httpVersion = `${versionMajor}.${versionMinor}`;
>>   incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
>>                                   parser.joinDuplicateHeaders;
>>   incoming.url = url;
>>   incoming.upgrade = upgrade;
>>
>>   let n = headers.length;
>>
>>   // If parser.maxHeaderPairs <= 0 assume that there's no limit.
>>   if (parser.maxHeaderPairs > 0)
>>     n = MathMin(n, parser.maxHeaderPairs);
>>
>>   incoming._addHeaderLines(headers, n);
>>
>>   if (typeof method === 'number') {
>>     // server only
>>     incoming.method = methods[method];
>>   } else {
>>     // client only
>>     incoming.statusCode = statusCode;
>>     incoming.statusMessage = statusMessage;
>>   }
>>
>>   return parser.onIncoming(incoming, shouldKeepAlive);
>> }
>>
Oops, something went wrong.  Please report this bug with the details below.
Report on GitHub: https://github.com/lzybkr/PSReadLine/issues/new
-----------------------------------------------------------------------
Last 200 Keys:
 Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space e r r o r . b y t e L e n g t h Space - Space 1 ) ; Enter
 Space Space Space Space Space Space r e t u r n Space b u f . t o S t r i n g ( ' u t f 8 ' ) ; Enter
 Space Space Space Space } Enter
 Space Space } Enter
 Space Space r e q u i r e ( ' a s s e r t ' ) . f a i l ( ' T h i s Space s h o u l d Space n o t Space h a p p e n ' ) ; Enter
 } Enter
 Enter
 m o d u l e . e x p o r t s Space = Space { Space s e r i a l i z e E r r o r , Space d e s e r i a l i z e E r r o r Space } ; Enter


Exception:
System.ArgumentOutOfRangeException: The value must be greater than or equal to zero and less than the console's buffer size in that dimension.
Parameter name: top
Actual value was -38.
   at System.Console.SetCursorPosition(Int32 left, Int32 top)
   at Microsoft.PowerShell.PSConsoleReadLine.ReallyRender(RenderData renderData, String defaultColor)
   at Microsoft.PowerShell.PSConsoleReadLine.ForceRender()
   at Microsoft.PowerShell.PSConsoleReadLine.Insert(Char c)
   at Microsoft.PowerShell.PSConsoleReadLine.AcceptLineImpl(Boolean validate)
   at Microsoft.PowerShell.PSConsoleReadLine.ProcessOneKey(ConsoleKeyInfo key, Dictionary`2 dispatchTable, Boolean ignoreIfNoAction, Object arg)
   at Microsoft.PowerShell.PSConsoleReadLine.InputLoop()
   at Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Runspace runspace, EngineIntrinsics engineIntrinsics)
-----------------------------------------------------------------------
PS C:\Users\ts> function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
>>                                  url, statusCode, statusMessage, upgrade,
>>                                  shouldKeepAlive) {
>>   const parser = this;
>>   const { socket } = parser;
>>
>>   if (headers === undefined) {
>>     headers = parser._headers;
>>     parser._headers = [];
>>   }
>>
>>   if (url === undefined) {
>>     url = parser._url;
>>     parser._url = '';
>>   }
>>
>>   // Parser is also used by http client
>>   const ParserIncomingMessage = (socket && socket.server &&
>>                                  socket.server[kIncomingMessage]) ||
>>                                  IncomingMessage;
>>
>>   const incoming = parser.incoming = new ParserIncomingMessage(socket);
>>   incoming.httpVersionMajor = versionMajor;
>>   incoming.httpVersionMinor = versionMinor;
>>   incoming.httpVersion = `${versionMajor}.${versionMinor}`;
>>   incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
>>                                   parser.joinDuplicateHeaders;
>>   incoming.url = url;
>>   incoming.upgrade = upgrade;
>> 
>>   let n = headers.length;
>>
>>   // If parser.maxHeaderPairs <= 0 assume that there's no limit.
>>   if (parser.maxHeaderPairs > 0)
>>     n = MathMin(n, parser.maxHeaderPairs);
>>
>>   incoming._addHeaderLines(headers, n);
>>
>>   if (typeof method === 'number') {
>>     // server only
>>     incoming.method = methods[method];
>>   } else {
>>     // client only
>>     incoming.statusCode = statusCode;
>>     incoming.statusMessage = statusMessage;
>>   }
>>
>>   return parser.onIncoming(incoming, shouldKeepAlive);
>> }
>>
>> function parserOnBody(b) {
>>   const stream = this.incoming;
>>
>>   // If the stream has already been removed, then drop it.
>>   if (stream === null)
>>     return;
>>
>>   // Pretend this was the result of a stream._read call.
>>   if (!stream._dumped) {
>>     const ret = stream.push(b);
>>     if (!ret)
>>       readStop(this.socket);
>>   }
>> }
>>
>> function parserOnMessageComplete() {
>>   const parser = this;
>>   const stream = parser.incoming;
>>
>>   if (stream !== null) {
>>     stream.complete = true;
>>     // Emit any trailing headers.
>>     const headers = parser._headers;
>>     if (headers.length) {
>>
Oops, something went wrong.  Please report this bug with the details below.
Report on GitHub: https://github.com/lzybkr/PSReadLine/issues/new
-----------------------------------------------------------------------
Last 200 Keys:
 Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space e r r o r . b y t e L e n g t h Space - Space 1 ) ; Enter
 Space Space Space Space Space Space r e t u r n Space b u f . t o S t r i n g ( ' u t f 8 ' ) ; Enter
 Space Space Space Space } Enter
 Space Space } Enter
 Space Space r e q u i r e ( ' a s s e r t ' ) . f a i l ( ' T h i s Space s h o u l d Space n o t Space h a p p e n ' ) ; Enter
 } Enter
 Enter
 m o d u l e . e x p o r t s Space = Space { Space s e r i a l i z e E r r o r , Space d e s e r i a l i z e E r r o r Space } ; Enter


Exception:
System.ArgumentOutOfRangeException: The value must be greater than or equal to zero and less than the console's buffer size in that dimension.
Parameter name: top
Actual value was -63.
   at System.Console.SetCursorPosition(Int32 left, Int32 top)
   at Microsoft.PowerShell.PSConsoleReadLine.ReallyRender(RenderData renderData, String defaultColor)
   at Microsoft.PowerShell.PSConsoleReadLine.ForceRender()
   at Microsoft.PowerShell.PSConsoleReadLine.Insert(Char c)
   at Microsoft.PowerShell.PSConsoleReadLine.AcceptLineImpl(Boolean validate)
   at Microsoft.PowerShell.PSConsoleReadLine.ProcessOneKey(ConsoleKeyInfo key, Dictionary`2 dispatchTable, Boolean ignoreIfNoAction, Object arg)
   at Microsoft.PowerShell.PSConsoleReadLine.InputLoop()
   at Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Runspace runspace, EngineIntrinsics engineIntrinsics)
-----------------------------------------------------------------------
PS C:\Users\ts> function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
>>                                  url, statusCode, statusMessage, upgrade,
>>                                  shouldKeepAlive) {
>>   const parser = this;
>>   const { socket } = parser;
>>
>>   if (headers === undefined) {
>>     headers = parser._headers;
>>     parser._headers = [];
>>   }
>>
>>   if (url === undefined) {
>>     url = parser._url;
>>     parser._url = '';
>>   }
>>
>>   // Parser is also used by http client
>>   const ParserIncomingMessage = (socket && socket.server &&
>>                                  socket.server[kIncomingMessage]) ||
>>                                  IncomingMessage;
>>
>>   const incoming = parser.incoming = new ParserIncomingMessage(socket);
>>   incoming.httpVersionMajor = versionMajor;
>>   incoming.httpVersionMinor = versionMinor;
>>   incoming.httpVersion = `${versionMajor}.${versionMinor}`;
>>   incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
>>                                   parser.joinDuplicateHeaders;
>>   incoming.url = url;
>>   incoming.upgrade = upgrade;
>>
>>   let n = headers.length;
>>
>>   // If parser.maxHeaderPairs <= 0 assume that there's no limit.
>>   if (parser.maxHeaderPairs > 0)
>>     n = MathMin(n, parser.maxHeaderPairs);
>>
>>   incoming._addHeaderLines(headers, n);
>>
>>   if (typeof method === 'number') {
>>     // server only
>>     incoming.method = methods[method];
>>   } else {
>>     // client only
>>     incoming.statusCode = statusCode;
>>     incoming.statusMessage = statusMessage;
>>   }
>>
>>   return parser.onIncoming(incoming, shouldKeepAlive);
>> }
>>
>> function parserOnBody(b) {
>>   const stream = this.incoming;
>>
>>   // If the stream has already been removed, then drop it.
>>   if (stream === null)
>>     return;
>>
>>   // Pretend this was the result of a stream._read call.
>>   if (!stream._dumped) {
>>     const ret = stream.push(b);
>>     if (!ret)
>>       readStop(this.socket);
>>   }
>> }
>>
>> function parserOnMessageComplete() {
>>   const parser = this;
>>   const stream = parser.incoming;
>>
>>   if (stream !== null) {
>>     stream.complete = true;
>>     // Emit any trailing headers.
>>     const headers = parser._headers;
>>     if (headers.length) {
>>       stream._addHeaderLines(headers, headers.length);
>>       parser._headers = [];
>>       parser._url = '';
>>     }
>>
>>     // For emit end event
>>     stream.push(null);
>>   }
>>
>>   // Force to read the next incoming message
>>   readStart(parser.socket);
>> }
>>
>> 
>> const parsers = new FreeList('parsers', 1000, function parsersCb() {
>>   const parser = new HTTPParser();
>>
>>   cleanParser(parser);
>>
>>   parser[kOnHeaders] = parserOnHeaders;
>>   parser[kOnHeadersComplete] = parserOnHeadersComplete;
>>   parser[kOnBody] = parserOnBody;
>>   parser[kOnMessageComplete] = parserOnMessageComplete;
>>
>>   return parser;
>> });
>> 
>> function closeParserInstance(parser) { parser.close(); }
>>
>> // Free the parser and also break any links that it
>> // might hav
Oops, something went wrong.  Please report this bug with the details below.
Report on GitHub: https://github.com/lzybkr/PSReadLine/issues/new
-----------------------------------------------------------------------
Last 200 Keys:
 Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space e r r o r . b y t e L e n g t h Space - Space 1 ) ; Enter
 Space Space Space Space Space Space r e t u r n Space b u f . t o S t r i n g ( ' u t f 8 ' ) ; Enter
 Space Space Space Space } Enter
 Space Space } Enter
 Space Space r e q u i r e ( ' a s s e r t ' ) . f a i l ( ' T h i s Space s h o u l d Space n o t Space h a p p e n ' ) ; Enter
 } Enter
 Enter
 m o d u l e . e x p o r t s Space = Space { Space s e r i a l i z e E r r o r , Space d e s e r i a l i z e E r r o r Space } ; Enter


Exception:
System.ArgumentOutOfRangeException: The value must be greater than or equal to zero and less than the console's buffer size in that dimension.
Parameter name: top
Actual value was -93.
   at System.Console.SetCursorPosition(Int32 left, Int32 top)
   at Microsoft.PowerShell.PSConsoleReadLine.ReallyRender(RenderData renderData, String defaultColor)
   at Microsoft.PowerShell.PSConsoleReadLine.ForceRender()
   at Microsoft.PowerShell.PSConsoleReadLine.Insert(Char c)
   at Microsoft.PowerShell.PSConsoleReadLine.SelfInsert(Nullable`1 key, Object arg)
   at Microsoft.PowerShell.PSConsoleReadLine.ProcessOneKey(ConsoleKeyInfo key, Dictionary`2 dispatchTable, Boolean ignoreIfNoAction, Object arg)
   at Microsoft.PowerShell.PSConsoleReadLine.InputLoop()
   at Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Runspace runspace, EngineIntrinsics engineIntrinsics)
-----------------------------------------------------------------------
PS C:\Users\ts> function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
>>                                  url, statusCode, statusMessage, upgrade,
>>                                  shouldKeepAlive) {
>>   const parser = this;
>>   const { socket } = parser;
>>
>>   if (headers === undefined) {
>>     headers = parser._headers;
>>     parser._headers = [];
>>   }
>>
>>   if (url === undefined) {
>>     url = parser._url;
>>     parser._url = '';
>>   }
>>
>>   // Parser is also used by http client
>>   const ParserIncomingMessage = (socket && socket.server &&
>>                                  socket.server[kIncomingMessage]) ||
>>                                  IncomingMessage;
>>
>>   const incoming = parser.incoming = new ParserIncomingMessage(socket);
>>   incoming.httpVersionMajor = versionMajor;
>>   incoming.httpVersionMinor = versionMinor;
>>   incoming.httpVersion = `${versionMajor}.${versionMinor}`;
>>   incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
>>                                   parser.joinDuplicateHeaders;
>>   incoming.url = url;
>>   incoming.upgrade = upgrade;
>>
>>   let n = headers.length;
>>
>>   // If parser.maxHeaderPairs <= 0 assume that there's no limit.
>>   if (parser.maxHeaderPairs > 0)
>>     n = MathMin(n, parser.maxHeaderPairs);
>>
>>   incoming._addHeaderLines(headers, n);
>>
>>   if (typeof method === 'number') {
>>     // server only
>>     incoming.method = methods[method];
>>   } else {
>>     // client only
>>     incoming.statusCode = statusCode;
>>     incoming.statusMessage = statusMessage;
>>   }
>> 
>>   return parser.onIncoming(incoming, shouldKeepAlive);
>> }
>>
>> function parserOnBody(b) {
>>   const stream = this.incoming;
>>
>>   // If the stream has already been removed, then drop it.
>>   if (stream === null)
>>     return;
>>
>>   // Pretend this was the result of a stream._read call.
>>   if (!stream._dumped) {
>>     const ret = stream.push(b);
>>     if (!ret)
>>       readStop(this.socket);
>>   }
>> }
>>
>> function parserOnMessageComplete() {
>>   const parser = this;
>>   const stream = parser.incoming;
>>
>>   if (stream !== null) {
>>     stream.complete = true;
>>     // Emit any trailing headers.
>>     const headers = parser._headers;
>>     if (headers.length) {
>>       stream._addHeaderLines(headers, headers.length);
>>       parser._headers = [];
>>       parser._url = '';
>>     }
>>
>>     // For emit end event
>>     stream.push(null);
>>   }
>>
>>   // Force to read the next incoming message
>>   readStart(parser.socket);
>> }
>> 
>>
>> const parsers = new FreeList('parsers', 1000, function parsersCb() {
>>   const parser = new HTTPParser();
>>
>>   cleanParser(parser);
>>
>>   parser[kOnHeaders] = parserOnHeaders;
>>   parser[kOnHeadersComplete] = parserOnHeadersComplete;
>>   parser[kOnBody] = parserOnBody;
>>   parser[kOnMessageComplete] = parserOnMessageComplete;
>>
>>   return parser;
>> });
>>
>> function closeParserInstance(parser) { parser.close(); }
>>
>> // Free the parser and also break any links that it
>> // might have to any other things.
>> // TODO: All parser data should be attached to a
>> // single object, so that it can be easily cleaned
>> // up by doing `parser.data = {}`, which should
>> // be done in FreeList.free.  `parsers.free(parser)`
>> // should be all that is needed.
>> function freeParser(parser, req, socket) {
>>   if (parser) {
>>     if (parser._consumed)
>>       parser.unconsume();
>>     cleanParser(parser);
>>     parser.remove();
>>     if (parsers.free(parser) === false) {
>>       // Make sure the parser's stack has unwound before deleting the
>>       // corresponding C++ object through .clo
Oops, something went wrong.  Please report this bug with the details below.
Report on GitHub: https://github.com/lzybkr/PSReadLine/issues/new
-----------------------------------------------------------------------
Last 200 Keys:
 Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space e r r o r . b y t e L e n g t h Space - Space 1 ) ; Enter
 Space Space Space Space Space Space r e t u r n Space b u f . t o S t r i n g ( ' u t f 8 ' ) ; Enter
 Space Space Space Space } Enter
 Space Space } Enter
 Space Space r e q u i r e ( ' a s s e r t ' ) . f a i l ( ' T h i s Space s h o u l d Space n o t Space h a p p e n ' ) ; Enter
 } Enter
 Enter
 m o d u l e . e x p o r t s Space = Space { Space s e r i a l i z e E r r o r , Space d e s e r i a l i z e E r r o r Space } ; Enter


Exception:
System.ArgumentOutOfRangeException: The value must be greater than or equal to zero and less than the console's buffer size in that dimension.
Parameter name: top
Actual value was -107.
   at System.Console.SetCursorPosition(Int32 left, Int32 top)
   at Microsoft.PowerShell.PSConsoleReadLine.ReallyRender(RenderData renderData, String defaultColor)
   at Microsoft.PowerShell.PSConsoleReadLine.ForceRender()
   at Microsoft.PowerShell.PSConsoleReadLine.Insert(Char c)
   at Microsoft.PowerShell.PSConsoleReadLine.AcceptLineImpl(Boolean validate)
   at Microsoft.PowerShell.PSConsoleReadLine.ProcessOneKey(ConsoleKeyInfo key, Dictionary`2 dispatchTable, Boolean ignoreIfNoAction, Object arg)
   at Microsoft.PowerShell.PSConsoleReadLine.InputLoop()
   at Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Runspace runspace, EngineIntrinsics engineIntrinsics)
-----------------------------------------------------------------------
PS C:\Users\ts> function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
>>                                  url, statusCode, statusMessage, upgrade,
>>                                  shouldKeepAlive) {
>>   const parser = this;
>>   const { socket } = parser;
>>
>>   if (headers === undefined) {
>>     headers = parser._headers;
>>     parser._headers = [];
>>   }
>>
>>   if (url === undefined) {
>>     url = parser._url;
>>     parser._url = '';
>>   }
>>
>>   // Parser is also used by http client
>>   const ParserIncomingMessage = (socket && socket.server &&
>>                                  socket.server[kIncomingMessage]) ||
>>                                  IncomingMessage;
>>
>>   const incoming = parser.incoming = new ParserIncomingMessage(socket);
>>   incoming.httpVersionMajor = versionMajor;
>>   incoming.httpVersionMinor = versionMinor;
>>   incoming.httpVersion = `${versionMajor}.${versionMinor}`;
>>   incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
>>                                   parser.joinDuplicateHeaders;
>>   incoming.url = url;
>>   incoming.upgrade = upgrade;
>>
>>   let n = headers.length;
>>
>>   // If parser.maxHeaderPairs <= 0 assume that there's no limit.
>>   if (parser.maxHeaderPairs > 0)
>>     n = MathMin(n, parser.maxHeaderPairs);
>>
>>   incoming._addHeaderLines(headers, n);
>>
>>   if (typeof method === 'number') {
>>     // server only
>>     incoming.method = methods[method];
>>   } else {
>>     // client only
>>     incoming.statusCode = statusCode;
>>     incoming.statusMessage = statusMessage;
>>   }
>>
>>   return parser.onIncoming(incoming, shouldKeepAlive);
>> }
>>
>> function parserOnBody(b) {
>>   const stream = this.incoming;
>>
>>   // If the stream has already been removed, then drop it.
>>   if (stream === null)
>>     return;
>>
>>   // Pretend this was the result of a stream._read call.
>>   if (!stream._dumped) {
>>     const ret = stream.push(b);
>>     if (!ret)
>>       readStop(this.socket);
>>   }
>> }
>>
>> function parserOnMessageComplete() {
>>   const parser = this;
>>   const stream = parser.incoming;
>>
>>   if (stream !== null) {
>>     stream.complete = true;
>>     // Emit any trailing headers.
>>     const headers = parser._headers;
>>     if (headers.length) {
>>       stream._addHeaderLines(headers, headers.length);
>>       parser._headers = [];
>>       parser._url = '';
>>     }
>> 
>>     // For emit end event
>>     stream.push(null);
>>   }
>>
>>   // Force to read the next incoming message
>>   readStart(parser.socket);
>> }
>>
>>
>> const parsers = new FreeList('parsers', 1000, function parsersCb() {
>>   const parser = new HTTPParser();
>>
>>   cleanParser(parser);
>>
>>   parser[kOnHeaders] = parserOnHeaders;
>>   parser[kOnHeadersComplete] = parserOnHeadersComplete;
>>   parser[kOnBody] = parserOnBody;
>>   parser[kOnMessageComplete] = parserOnMessageComplete;
>>
>>   return parser;
>> });
>>
>> function closeParserInstance(parser) { parser.close(); }
>>
>> // Free the parser and also break any links that it
>> // might have to any other things.
>> // TODO: All parser data should be attached to a
>> // single object, so that it can be easily cleaned
>> // up by doing `parser.data = {}`, which should
>> // be done in FreeList.free.  `parsers.free(parser)`
>> // should be all that is needed.
>> function freeParser(parser, req, socket) {
>>   if (parser) {
>>     if (parser._consumed)
>>       parser.unconsume();
>>     cleanParser(parser);
>>     parser.remove();
>>     if (parsers.free(parser) === false) {
>>       // Make sure the parser's stack has unwound before deleting the
>>       // corresponding C++ object through .close().
>>       setImmediate(closeParserInstance, parser);
>>     } else {
>>       // Since the Parser destructor isn't going to run the destroy() callbacks
>>       // it needs to be triggered manually.
>>       parser.free();
>>     }
>>   }
>>   if (req) {
>>     req.parser = null;
>>   }
>>   if (socket) {
>>     socket.parser = null;
>>   }
>> }
>>
Oops, something went wrong.  Please report this bug with the details below.
Report on GitHub: https://github.com/lzybkr/PSReadLine/issues/new
-----------------------------------------------------------------------
Last 200 Keys:
 Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space Space e r r o r . b y t e L e n g t h Space - Space 1 ) ; Enter
 Space Space Space Space Space Space r e t u r n Space b u f . t o S t r i n g ( ' u t f 8 ' ) ; Enter
 Space Space Space Space } Enter
 Space Space } Enter
 Space Space r e q u i r e ( ' a s s e r t ' ) . f a i l ( ' T h i s Space s h o u l d Space n o t Space h a p p e n ' ) ; Enter
 } Enter
 Enter
 m o d u l e . e x p o r t s Space = Space { Space s e r i a l i z e E r r o r , Space d e s e r i a l i z e E r r o r Space } ; Enter


Exception:
System.ArgumentOutOfRangeException: The value must be greater than or equal to zero and less than the console's buffer size in that dimension.
Parameter name: top
Actual value was -122.
   at System.Console.SetCursorPosition(Int32 left, Int32 top)
   at Microsoft.PowerShell.PSConsoleReadLine.ReallyRender(RenderData renderData, String defaultColor)
   at Microsoft.PowerShell.PSConsoleReadLine.ForceRender()
   at Microsoft.PowerShell.PSConsoleReadLine.Insert(Char c)
   at Microsoft.PowerShell.PSConsoleReadLine.SelfInsert(Nullable`1 key, Object arg)
   at Microsoft.PowerShell.PSConsoleReadLine.ProcessOneKey(ConsoleKeyInfo key, Dictionary`2 dispatchTable, Boolean ignoreIfNoAction, Object arg)
   at Microsoft.PowerShell.PSConsoleReadLine.InputLoop()
   at Microsoft.PowerShell.PSConsoleReadLine.ReadLine(Runspace runspace, EngineIntrinsics engineIntrinsics)
-----------------------------------------------------------------------
PS C:\Users\ts> function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
>>                                  url, statusCode, statusMessage, upgrade,
>>                                  shouldKeepAlive) {
>>   const parser = this;
>>   const { socket } = parser;
>>
>>   if (headers === undefined) {
>>     headers = parser._headers;
>>     parser._headers = [];
>>   }
>>
>>   if (url === undefined) {
>>     url = parser._url;
>>     parser._url = '';
>>   }
>>
>>   // Parser is also used by http client
>>   const ParserIncomingMessage = (socket && socket.server &&
>>                                  socket.server[kIncomingMessage]) ||
>>                                  IncomingMessage;
>>
>>   const incoming = parser.incoming = new ParserIncomingMessage(socket);
>>   incoming.httpVersionMajor = versionMajor;
>>   incoming.httpVersionMinor = versionMinor;
>>   incoming.httpVersion = `${versionMajor}.${versionMinor}`;
>>   incoming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
>>                                   parser.joinDuplicateHeaders;
>>   incoming.url = url;
>>   incoming.upgrade = upgrade;
>>
>>   let n = headers.length;
>>
>>   // If parser.maxHeaderPairs <= 0 assume that there's no limit.
>>   if (parser.maxHeaderPairs > 0)
>>     n = MathMin(n, parser.maxHeaderPairs);
>>
>>   incoming._addHeaderLines(headers, n);
>>
>>   if (typeof method === 'number') {
>>     // server only
>>     incoming.method = methods[method];
>>   } else {
>>     // client only
>>     incoming.statusCode = statusCode;
>>     incoming.statusMessage = statusMessage;
>>   }
>> 
>>   return parser.onIncoming(incoming, shouldKeepAlive);
>> }
>>
>> function parserOnBody(b) {
>>   const stream = this.incoming;
>>
>>   // If the stream has already been removed, then drop it.
>>   if (stream === null)
>>     return;
>>
>>   // Pretend this was the result of a stream._read call.
>>   if (!stream._dumped) {
>>     const ret = stream.push(b);
>>     if (!ret)
>>       readStop(this.socket);
>>   }
>> }
>>
>> function parserOnMessageComplete() {
>>   const parser = this;
>>   const stream = parser.incoming;
>>
>>   if (stream !== null) {
>>     stream.complete = true;
>>     // Emit any trailing headers.
>>     const headers = parser._headers;
>>     if (headers.length) {
>>       stream._addHeaderLines(headers, headers.length);
>>       parser._headers = [];
>>       parser._url = '';
>>     }
>> 
>>     // For emit end event
>>     stream.push(null);
>>   }
>>
>>   // Force to read the next incoming message
>>   readStart(parser.socket);
>> }
>>
>>
>> const parsers = new FreeList('parsers', 1000, function parsersCb() {
>>   const parser = new HTTPParser();
>>
>>   cleanParser(parser);
>>
>>   parser[kOnHeaders] = parserOnHeaders;
>>   parser[kOnHeadersComplete] = parserOnHeadersComplete;
>>   parser[kOnBody] = parserOnBody;
>>   parser[kOnMessageComplete] = parserOnMessageComplete;
>>
>>   return parser;
>> });
>>
>> function closeParserInstance(parser) { parser.close(); }
>>
>> // Free the parser and also break any links that it
>> // might have to any other things.
>> // TODO: All parser data should be attached to a
>> // single object, so that it can be easily cleaned
>> // up by doing `parser.data = {}`, which should
>> // be done in FreeList.free.  `parsers.free(parser)`
>> // should be all that is needed.
>> function freeParser(parser, req, socket) {
>>   if (parser) {
>>     if (parser._consumed)
>>       parser.unconsume();
>>     cleanParser(parser);
>>     parser.remove();
>>     if (parsers.free(parser) === false) {
>>       // Make sure the parser's stack has unwound before deleting the
>>       // corresponding C++ object through .close().
>>       setImmediate(closeParserInstance, parser);
>>     } else {
>>       // Since the Parser destructor isn't going to run the destroy() callbacks
>>       // it needs to be triggered manually.
>>       parser.free();
>>     }
>>   }
>>   if (req) {
>>     req.parser = null;
>>   }
>>   if (socket) {
>>     socket.parser = null;
>> }
>>
>> const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
>> /**
>>  * Verifies that the given val is a valid HTTP token
>>  * per the rules defined in RFC 7230
>>  * See https://tools.ietf.org/html/rfc7230#section-3.2.6
>>  */
>> function checkIsHttpToken(val) {
>>   return RegExpPrototypeExec(tokenRegExp, val) !== null;
>> }
At line:1 char:34
+ function parserOnHeadersComplete(versionMajor, versionMinor, headers, ...
+                                  ~
Missing ')' in function parameter list.
At line:1 char:46
+ function parserOnHeadersComplete(versionMajor, versionMinor, headers, ...
+                                              ~
Missing argument in parameter list.
At line:3 char:49
+                                  shouldKeepAlive) {
+                                                 ~
Unexpected token ')' in expression or statement.
At line:18 char:41
+   const ParserIncomingMessage = (socket && socket.server &&
+                                         ~~
The token '&&' is not a valid statement separator in this version.
At line:18 char:58
+   const ParserIncomingMessage = (socket && socket.server &&
+                                                          ~~
The token '&&' is not a valid statement separator in this version.
At line:19 char:67
+                                  socket.server[kIncomingMessage]) ||
+                                                                   ~~
The token '||' is not a valid statement separator in this version.
At line:25 char:43
+   incoming.httpVersion = `${versionMajor}.${versionMinor}`;
+                                           ~
Missing property name after reference operator.
At line:26 char:72
+ ... coming.joinDuplicateHeaders = socket?.server?.joinDuplicateHeaders ||
+                                                                        ~~
The token '||' is not a valid statement separator in this version.
At line:33 char:31
The '<' operator is reserved for future use.
At line:119 char:50
+       // corresponding C++ object through .close().
+                                                  ~
An expression was expected after '('.
Not all parse errors were reported.  Correct the reported errors and try again.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException
    + FullyQualifiedErrorId : MissingEndParenthesisInFunctionParameterList
 
PS C:\Users\ts> const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
const : The term 'const' is not recognized as the name of a cmdlet, function, script file, or       
operable program. Check the spelling of the name, or if a path was included, verify that the path   
is correct and try again.
At line:1 char:1
+ const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
+ ~~~~~
    + CategoryInfo          : ObjectNotFound: (const:String) [], CommandNotFoundException
    + FullyQualifiedErrorId : CommandNotFoundException
PS C:\Users\ts> /**
/** : The term '/**' is not recognized as the name of a cmdlet, function, script file, or operable  
program. Check the spelling of the name, or if a path was included, verify that the path is         
correct and try again.
At line:1 char:1
+ /**
+ ~~~
    + CategoryInfo          : ObjectNotFound: (/**:String) [], CommandNotFoundException
    + FullyQualifiedErrorId : CommandNotFoundException
PS C:\Users\ts>  * True if val contains an invalid field-vchar
* : The term '*' is not recognized as the name of a cmdlet, function, script file, or operable      
program. Check the spelling of the name, or if a path was included, verify that the path is         
correct and try again.
At line:1 char:2
+  * True if val contains an invalid field-vchar
+  ~
    + CategoryInfo          : ObjectNotFound: (*:String) [], CommandNotFoundException
    + FullyQualifiedErrorId : CommandNotFoundException
PS C:\Users\ts>  *  field-value    = *( field-content / obs-fold )
field-content : The term 'field-content' is not recognized as the name of a cmdlet, function,       
script file, or operable program. Check the spelling of the name, or if a path was included,        
verify that the path is correct and try again.
At line:1 char:25
+  *  field-value    = *( field-content / obs-fold )
+                         ~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (field-content:String) [], CommandNotFoundException   
    + FullyQualifiedErrorId : CommandNotFoundException
 
PS C:\Users\ts>  *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]

cmdlet Set-ItemProperty at command pipeline position 1
Supply values for the following parameters: